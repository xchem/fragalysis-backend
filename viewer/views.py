import json
import os
import zipfile
from io import StringIO
import pandas as pd
import uuid
import shutil

# import the logging library
import logging
# Get an instance of a logger
logger = logging.getLogger(__name__)

from django.db import connections
from django.http import HttpResponse
from django.shortcuts import render
from rest_framework import viewsets
from django.core.files.storage import default_storage
from django.core.files.base import ContentFile
from django.core.mail import send_mail
from django.conf import settings
from django.http import JsonResponse

from rest_framework.parsers import JSONParser, BaseParser
from rest_framework.exceptions import ParseError
from rest_framework.views import APIView
from rest_framework.response import Response

from django.views import View

from celery.result import AsyncResult

from api.security import ISpyBSafeQuerySet
from api.utils import get_params, get_highlighted_diffs

from viewer.models import (
    Molecule,
    Protein,
    Compound,
    Target,
    ActionType,
    SessionProject,
    SessionActions,
    Snapshot,
    SnapshotActions,
    ComputedMolecule,
    ComputedSet,
    CSetKeys,
    NumericalScoreValues,
    ScoreDescription,
    File
)
from viewer import filters
from .forms import CSetForm, UploadKeyForm, CSetUpdateForm, TSetForm

from .tasks import *
from .discourse import create_discourse_post, list_discourse_posts_for_topic, check_discourse_user


from viewer.serializers import (
    MoleculeSerializer,
    ProteinSerializer,
    CompoundSerializer,
    TargetSerializer,
    MolImageSerialzier,
    CmpdImageSerialzier,
    ProtMapInfoSerialzer,
    ProtPDBInfoSerialzer,
    ProtPDBBoundInfoSerialzer,
    VectorsSerializer,
    GraphSerializer,
    ActionTypeSerializer,
    SessionProjectWriteSerializer,
    SessionProjectReadSerializer,
    SessionActionsSerializer,
    SnapshotReadSerializer,
    SnapshotWriteSerializer,
    SnapshotActionsSerializer,
    FileSerializer,
    ComputedSetSerializer,
    ComputedMoleculeSerializer,
    NumericalScoreSerializer,
    ScoreDescriptionSerializer,
    TextScoreSerializer,
    ComputedMolAndScoreSerializer,
    DiscoursePostWriteSerializer,
    DictToCsvSerializer
)


class VectorsView(ISpyBSafeQuerySet):
    """ DjagnoRF view for vectors

    Methods
    -------
    url:
        api/vector
    queryset:
        `viewer.models.Molecule.objects.filter()`
    filter fields:
        - `viewer.models.Molecule.prot_id` - ?prot_id=<int>
        - `viewer.models.Molecule.cmpd_id` - ?cmpd_id=<int>
        - `viewer.models.Molecule.smiles` - ?smiles=<str>
        - `viewer.models.Molecule.prot_id__target_id` - ?target_id=<int>
    returns:
        vectors for a given molecule generated by `frag.network.generate.get_3d_vects_for_mol()` (JSON)

    """
    queryset = Molecule.objects.filter()
    serializer_class = VectorsSerializer
    filter_permissions = "prot_id__target_id__project_id"
    filter_fields = ("prot_id", "cmpd_id", "smiles", "prot_id__target_id", "mol_groups")


class GraphView(ISpyBSafeQuerySet):
    """ DjagnoRF view for graph

    Methods
    -------
    url:
        api/graph
    queryset:
        `viewer.models.Molecule.objects.filter()`
    filter fields:
        - `viewer.models.Molecule.prot_id` - ?prot_id=<int>
        - `viewer.models.Molecule.cmpd_id` - ?cmpd_id=<int>
        - `viewer.models.Molecule.smiles` - ?smiles=<str>
        - `viewer.models.Molecule.prot_id__target_id` - ?target_id=<int>
        - `viewer.models.Molecule.mol_groups` - ?mol_groups=<int>,<int>
    returns:
        graph network results for given molecule from `frag.network.query.get_full_graph()` (JSON)

    example output:

        .. code-block:: javascript

            "results": [
                {
                    "id": 385,
                    "graph": {
                        "CC(=O)Nc1cnccc1[Xe]_1_DELETION": {
                            "vector": "CC(O)NC1CCCCC1[101Xe]",
                            "addition": [
                                {
                                    "change": "C[101Xe]",
                                    "end": "CC(=O)Nc1cccnc1",
                                    "compound_ids": [
                                        "REAL:PV-001793547821",
                                        "MOLPORT:000-165-661"
                                    ]
                                }
                            ]
                        },
                        "C[Xe].NC(=O)C[Xe]_2_LINKER": {
                            "vector": "C[101Xe].NC(O)C[100Xe]",
                            "addition": [
                                {
                                    "change": "CNC1CC([100Xe])C(O)C1[101Xe]",
                                    "end": "CN=C1SC(CC(N)=O)C(=O)N1C",
                                    "compound_ids": [
                                        "MOLPORT:000-680-640"
                                    ]
                                },
                                {
                                    "change": "[100Xe]C1CCCCC1[101Xe]",
                                    "end": "CC1CCCCN1CC(N)=O",
                                    "compound_ids": [
                                        "REAL:Z54751033",
                                        "MOLPORT:001-599-191"
                                    ]
                                }
                            ]
                        },
                        "Cc1ccnc(Cl)c1[Xe]_2_REPLACE": {
                            "vector": "CC1CCCC(Cl)C1[100Xe]",
                            "addition": [
                                {
                                    "change": "CC(O)N[100Xe]",
                                    "end": "Cc1ccnc(Cl)c1",
                                    "compound_ids": [
                                        "MOLPORT:000-140-635"
                                    ]
                                }
                            ]
                        }
                    }
                }
        ]
    """
    queryset = Molecule.objects.filter()
    serializer_class = GraphSerializer
    filter_permissions = "prot_id__target_id__project_id"
    filter_fields = ("prot_id", "cmpd_id", "smiles", "prot_id__target_id", "mol_groups")


class MolImageView(ISpyBSafeQuerySet):
    """ DjagnoRF view for molecule images

    Methods
    -------
    url:
        api/molimg
    queryset:
        `viewer.models.Molecule.objects.filter()`
    filter fields:
        - `viewer.models.Molecule.prot_id` - ?prot_id=<int>
        - `viewer.models.Molecule.cmpd_id` - ?cmpd_id=<int>
        - `viewer.models.Molecule.smiles` - ?smiles=<str>
        - `viewer.models.Molecule.prot_id__target_id` - ?target_id=<int>
        - `viewer.models.Molecule.mol_groups` - ?mol_groups=<int>,<int>
    returns:
        SVG image text for query molecule generated by `api.utils.draw_mol()` (JSON)

    example output:

        .. code-block:: javascript

             "results": [
                    {"id": 13912,
                        "mol_image": "<?xml version='1.0' encoding='iso-8859-1'?><svg version='1.1' nk'..."}]
    """
    queryset = Molecule.objects.filter()
    serializer_class = MolImageSerialzier
    filter_permissions = "prot_id__target_id__project_id"
    filter_fields = ("prot_id", "cmpd_id", "smiles", "prot_id__target_id", "mol_groups")


class CompoundImageView(ISpyBSafeQuerySet):
    """ DjagnoRF view for compound images

   Methods
   -------
   url:
       api/cmpdimg
   queryset:
       `viewer.models.Compound.objects.filter()`
   filter fields:
       - `viewer.models.Molecule.smiles` - ?smiles=<str>
   returns:
       SVG image text for query compound generated by `api.utils.draw_mol()` (JSON)

   example output:

       .. code-block:: javascript

        "results": [
                {"id": 13912,
                    "mol_image": "<?xml version='1.0' encoding='iso-8859-1'?><svg version='1.1' nk'..."}]

    """
    queryset = Compound.objects.filter()
    serializer_class = CmpdImageSerialzier
    filter_permissions = "project_id"
    filter_fields = ("smiles",)


class ProteinMapInfoView(ISpyBSafeQuerySet):
    """ DjagnoRF view to retrieve map info (file) for a given protein

   Methods
   -------
   url:
       api/protmap
   queryset:
       `viewer.models.Protein.objects.filter()`
   filter fields:
       - `viewer.models.Protein.code` - ?code=<str>
       - `viewer.models.Protein.target_id` - ?target_id=<int>
       - `viewer.models.Protein.prot_type` - ?prot_type=<str>
   returns:
       If a map file has been uploaded for the protein `map_info.path.read()` (JSON)

   """
    queryset = Protein.objects.filter()
    serializer_class = ProtMapInfoSerialzer
    filter_permissions = "target_id__project_id"
    filter_fields = ("code", "target_id", "target_id__title", "prot_type")


class ProteinPDBInfoView(ISpyBSafeQuerySet):
    """ DjagnoRF view to retrieve apo pdb info (file) for a given protein

   Methods
   -------
   url:
       api/protpdb
   queryset:
       `viewer.models.Protein.objects.filter()`
   filter fields:
       - `viewer.models.Protein.code` - ?code=<str>
       - `viewer.models.Protein.target_id` - ?target_id=<int>
       - `viewer.models.Protein.prot_type` - ?prot_type=<str>
   returns: JSON
       - id: id of the protein object
       - pdb_data: If a pdb file has been uploaded for the protein `bound_info.path.read()`
       - prot_type: type of protein (e.g. AP for apo - see docs for model)

   example output:

       .. code-block:: javascript

           "results": [
            {
                "id": 27387,
                "pdb_data": "REMARK warning: chains may be ommitted for alignment REMARK ...",
                "prot_type": "AP"
            },]

   """
    queryset = Protein.objects.filter()
    serializer_class = ProtPDBInfoSerialzer
    filter_permissions = "target_id__project_id"
    filter_fields = ("code", "target_id", "target_id__title", "prot_type")


class ProteinPDBBoundInfoView(ISpyBSafeQuerySet):
    """ DjagnoRF view to retrieve bound pdb info (file) for a given protein

   Methods
   -------
   url:
       api/protpdbbound
   queryset:
       `viewer.models.Protein.objects.filter()`
   filter fields:
       - `viewer.models.Protein.code` - ?code=<str>
       - `viewer.models.Protein.target_id` - ?target_id=<int>
       - `viewer.models.Protein.prot_type` - ?prot_type=<str>
   returns: JSON
       - id: id of the protein object
       - pdb_data: If a pdb file has been uploaded for the protein `bound_info.path.read()`
       - prot_type: type of protein (e.g. AP for apo - see docs for model)

   example output:

       .. code-block:: javascript

           "results": [
            {
                "id": 27387,
                "pdb_data": "REMARK warning: chains may be ommitted for alignment REMARK ...",
                "prot_type": "AP"
            },]

   """
    queryset = Protein.objects.filter()
    serializer_class = ProtPDBBoundInfoSerialzer
    filter_permissions = "target_id__project_id"
    filter_fields = ("code", "target_id", "target_id__title", "prot_type")


class TargetView(ISpyBSafeQuerySet):
    """ DjagnoRF view to retrieve info about targets

       Methods
       -------
       url:
           api/targets
       queryset:
           `viewer.models.Target.objects.filter()`
       filter fields:
           - `viewer.models.Target.title` - ?title=<str>
       returns: JSON
           - id: id of the target object
           - title: name of the target
           - project_id: list of the ids of the projects the target is linked to
           - protein_set: list of the ids of the protein sets the target is linked to
           - template_protein: the template protein displayed in fragalysis front-end for this target
           - metadata: link to the metadata file for the target if it was uploaded
           - zip_archive: link to the zip archive of the uploaded data

       example output:

           .. code-block:: javascript

               "results": [
                {
                    "id": 62,
                    "title": "Mpro",
                    "project_id": [
                        2
                    ],
                    "protein_set": [
                        29281,
                        29274,
                        29259,
                        29305,
                        ...,
                    ],
                    "template_protein": "/media/pdbs/Mpro-x10417_0_apo.pdb",
                    "metadata": "http://fragalysis.diamond.ac.uk/media/metadata/metadata_2FdP5OJ.csv",
                    "zip_archive": "http://fragalysis.diamond.ac.uk/media/targets/Mpro.zip"
                }
            ]

       """
    queryset = Target.objects.filter()
    serializer_class = TargetSerializer
    filter_permissions = "project_id"
    filter_fields = ("title",)


class MoleculeView(ISpyBSafeQuerySet):
    """ DjagnoRF view to retrieve info about molecules

   Methods
   -------
   url:
       api/molecules
   queryset:
       `viewer.models.Molecule.objects.filter()`
   filter fields:
       - `viewer.models.Molecule.prot_id` - ?prot_id=<int>
       - `viewer.models.Molecule.cmpd_id` - ?cmpd_id=<int>
       - `viewer.models.Molecule.smiles` - ?smiles=<string>
       - `viewer.models.Molecule.prot_id__target_id` - ?target_id=<int>
       - `viewer.models.Molecule.mol_type` - ?mol_type=<str>
       - `viewer.models.Molecule.mol_groups` - ?mol_groups=<int>,<int>
   returns: JSON
       - id: id of the target object
       - smiles: smiles string of the molecule
       - cmpd_id: id of the related 2D compound object
       - prot_id: id of the related protein object
       - protein_code: code of the related protein object
       - mol_type: type of molecule - see Molecule model docs
       - molecule_protein: filepath of the apo protein structure for the molecule
       - lig_id: residue label for the ligand
       - chain_id: chain in the pdb file that the ligand belongs to
       - sdf_info: 3D coordinated of the molecule in MDL file format
       - x_com: x-coordinate for molecule centre of mass
       - y_com: y-coordinate for molecule centre of mass
       - z_com: z-coordinate for molecule centre of mass
       - mw: molecular weight
       - logp: LogP
       - tpsa: Topological Polar Surface Area
       - ha: heavy atom count
       - hacc: hydrogen-bond acceptors
       - hdon: hydrogen-bond donors
       - rots: number of rotatable bonds
       - rings: number of rings
       - velec: number of valence electrons

   example output:

       .. code-block:: javascript

           "results": [
            {
                "id": 13912,
                "smiles": "CN(C)c1ccc(C(=O)Nc2ccccn2)cc1",
                "cmpd_id": 796,
                "prot_id": 13923,
                "protein_code": "NUDT7A_Crude-x2226_2",
                "mol_type": "PR",
                "molecule_protein": "/media/pdbs/NUDT7A_Crude-x2226_2_apo_x5GxiLq.pdb",
                "lig_id": "LIG",
                "chain_id": "Z",
                "sdf_info": "     RDKit          3D 18 19  0  0  0  0  0  0  0  0999...",
                "x_com": null,
                "y_com": null,
                "z_com": null,
                "mw": 241.12,
                "logp": 2.4,
                "tpsa": 45.23,
                "ha": 18,
                "hacc": 3,
                "hdon": 1,
                "rots": 3,
                "rings": 2,
                "velec": 92
            },]

   """
    queryset = Molecule.objects.filter()
    serializer_class = MoleculeSerializer
    filter_permissions = "prot_id__target_id__project_id"
    filter_fields = (
        "prot_id",
        "prot_id__code",
        "cmpd_id",
        "smiles",
        "prot_id__target_id",
        "prot_id__target_id__title",
        "mol_type",
        "mol_groups",
    )


class CompoundView(ISpyBSafeQuerySet):
    """ DjagnoRF view for compound info

   Methods
   -------
   url:
       api/compounds
   queryset:
       `viewer.models.Compound.objects.filter()`
   filter fields:
       - `viewer.models.Molecule.smiles` - ?smiles=<str>
   returns:
       - id: id for compound object
       - inchi: inchi key for compound
       - smiles: smiles string for compound
       - mol_log_p: LogP for compound
       - num_h_acceptors: number of hydrogen-bond acceptors
       - num_h_donors: number of hydrogen-bond donors

   example output:

       .. code-block:: javascript

        "results": [
        {
            "id": 1,
            "inchi": "InChI=1S/C9H15NOS/c1-7(11)5-10-6-9-4-3-8(2)12-9/h3-4,7,10-11H,5-6H2,1-2H3/t7-/m0/s1",
            "smiles": "Cc1ccc(CNC[C@H](C)O)s1",
            "mol_log_p": 1.52692,
            "mol_wt": 185.0874351,
            "num_h_acceptors": 3,
            "num_h_donors": 2
        },]

    """
    queryset = Compound.objects.filter()
    serializer_class = CompoundSerializer
    filter_permissions = "project_id"
    filter_fields = ("smiles", "current_identifier", "inchi", "long_inchi")


class ProteinView(ISpyBSafeQuerySet):
    """ DjagnoRF view to retrieve bound pdb info (file) for a given protein

   Methods
   -------
   url:
       api/proteins
   queryset:
       `viewer.models.Protein.objects.filter()`
   filter fields:
       - `viewer.models.Protein.code` - ?code=<str>
       - `viewer.models.Protein.target_id` - ?target_id=<int>
       - `viewer.models.Protein.prot_type` - ?prot_type=<str>
   returns: JSON
       - id: id of the protein object
       - code: the code/name of the protein
       - target_id: the id of the related target object
       - prot_type: the type of protein (e.g. AP for apo)
       - pdb_info: link to the apo pdb file
       - bound_info: link to the bound pdb file
       - mtz_info: link to the mtz file
       - map_info: link to the map file
       - cif_info: link to the cif file

   example output:

       .. code-block:: javascript

           "results": [
            {
                "id": 14902,
                "code": "XX02KALRNA-x1376_1",
                "target_id": 51,
                "prot_type": "AP",
                "pdb_info": "http://fragalysis.diamond.ac.uk/media/pdbs/XX02KALRNA-x1376_1_apo_9VSCvR8.pdb",
                "bound_info": "http://fragalysis.diamond.ac.uk/media/bound/XX02KALRNA-x1376_1_bound_6xmXkUm.pdb",
                "mtz_info": null,
                "map_info": null,
                "cif_info": null
            },]

   """
    queryset = Protein.objects.filter()
    serializer_class = ProteinSerializer
    filter_permissions = "target_id__project_id"
    filter_fields = ("code", "target_id", "target_id__title", "prot_type")


def react(request):
    """
    :param request:
    :return: viewer/react page with context
    """
    discourse_api_key = settings.DISCOURSE_API_KEY

    context = {}
    if discourse_api_key:
        context['discourse_available'] = 'true'
    else:
        context['discourse_available'] = 'false'

    # If user is authenticated and a discourse api key is available, then check discourse to
    # see if user is set up and set up flag in context.
    user = request.user
    if user.is_authenticated and discourse_api_key:
        context['discourse_host'] = settings.DISCOURSE_HOST
        error, error_message, user_id = check_discourse_user(user)
        if user_id:
            context['user_present_on_discourse'] = 'true'
        else:
            context['user_present_on_discourse'] = 'false'

    return render(request, "viewer/react_temp.html", context)

# Upload Compound set functions


# email cset upload key
def cset_key(request):
    """ View to render and control viewer/generate-key.html - a page allowing an upload key to be generated for a user
    allowing upload of computed sets

    Methods
    -------
    allowed requests:
        - GET: renders form
        - POST: generates an upload key, emails it to the user, and informs the user that this will happen
    url:
       viewer/cset_key
    template:
        viewer/generate-key.html
    request params:
        - contact_email (django.forms.FormField): user contact email
    context:
        - form (`django.Forms.form`): instance of `viewer.forms.UploadKeyForm`
        - message (str): A message rendered in the template. Informs the user that their upload key will be emailed

    """

    form = UploadKeyForm()
    if request.method == 'POST':
        form = UploadKeyForm(request.POST)
        email = request.POST['contact_email']
        new_key = CSetKeys()
        new_key.user = email
        new_key.save()
        key_value = new_key.uuid

        subject = 'Fragalysis: upload compound set key'
        message = 'Your upload key is: ' + str(
            key_value) + ' store it somewhere safe. Only one key will be issued per user'
        email_from = settings.EMAIL_HOST_USER
        recipient_list = [email, ]
        send_mail(subject, message, email_from, recipient_list)

        msg = 'Your key will be emailed to: <b>' + email + '</b>'

        return render(request, 'viewer/generate-key.html', {'form': form, 'message': msg})
    return render(request, 'viewer/generate-key.html', {'form': form, 'message': ''})


def save_pdb_zip(pdb_file):
    zf = zipfile.ZipFile(pdb_file)
    zip_lst = zf.namelist()
    zfile = {}
    zfile_hashvals = {}
    print(zip_lst)
    for filename in zip_lst:
        # only handle pdb files
        if filename.split('.')[-1] == 'pdb':
            f = filename.split('/')[0]
            save_path = os.path.join(settings.MEDIA_ROOT, 'tmp', f)
            if default_storage.exists(f):
                rand_str = uuid.uuid4().hex
                pdb_path = default_storage.save(save_path.replace('.pdb', f'-{rand_str}.pdb'), ContentFile(zf.read(filename)))
            # Test if Protein object already exists
            # code = filename.split('/')[-1].replace('.pdb', '')
            # test_pdb_code = filename.split('/')[-1].replace('.pdb', '')
            # test_prot_objs = Protein.objects.filter(code=test_pdb_code)
            #
            # if len(test_prot_objs) > 0:
            #     # make a unique pdb code as not to overwrite existing object
            #     rand_str = uuid.uuid4().hex
            #     test_pdb_code = f'{code}#{rand_str}'
            #     zfile_hashvals[code] = rand_str
            #
            # fn = test_pdb_code + '.pdb'
            #
            # pdb_path = default_storage.save('tmp/' + fn,
            #                                 ContentFile(zf.read(filename)))
            else:
                pdb_path = default_storage.save(save_path, ContentFile(zf.read(filename)))
            test_pdb_code = pdb_path.split('/')[-1].replace('.pdb', '')
            zfile[test_pdb_code] = pdb_path

    # Close the zip file
    if zf:
        zf.close()

    return zfile, zfile_hashvals


def save_tmp_file(myfile):
    """ Save file in temporary location for validation/upload processing
    """

    name = myfile.name
    path = default_storage.save('tmp/' + name, ContentFile(myfile.read()))
    tmp_file = str(os.path.join(settings.MEDIA_ROOT, path))

    return tmp_file


class UpdateCSet(View):
    """ View to allow addition of new molecules/pdb files to an existing Computed Set

    Methods
    -------
    allowed requests:
        - GET: renders form
        - POST: validates and optionally uploads the computed set that the user provides via the template form
    url:
        viewer/upload_cset
    template:
        viewer/upload-cset.html
    request params:
        - target_name (`django.forms.CharField`): Name of the existing fragalysis target to add the computed set to
        - sdf_file (`django.forms.FileField`): SDF file of all computed molecules to upload for the computed set
        - pdb_zip (`django.forms.FileField`): zip file of apo pdb files referenced in the ref_pdb field for molecules in sdf_file (optional)
        - submit_choice (`django.forms.CharField`): 0 to validate, 1 to validate and upload
        - upload_key (`django.forms.CharField`): users unique upload key, generated by `viewer.views.cset_key`
    context:
        - form (`django.Forms.form`): instance of `viewer.forms.CSetForm`
        - validate_task_id (str): celery task id for validation step
        - validate_task_status (str): celery task status for validation step
        - upload_task_id (str): celery task id for upload step
        - upload_task_status (str): celery task status for upload step

    """
    def get(self, request):
        form = CSetUpdateForm()
        existing_sets = ComputedSet.objects.all()
        return render(request, 'viewer/update-cset.html', {'form': form, 'sets': existing_sets})

    def post(self, request):
        check_services()
        zfile = None
        form = CSetUpdateForm(request.POST, request.FILES)
        context = {}
        if form.is_valid():

            # get all of the variables needed from the form
            myfile = request.FILES['sdf_file']
            target = request.POST['target_name']

            # get update choice
            update_set = request.POST['update_set']

            if 'pdb_zip' in list(request.FILES.keys()):
                pdb_file = request.FILES['pdb_zip']
            else:
                pdb_file = None

            # if there is a zip file of pdbs, check it for .pdb files, and ignore others
            if pdb_file:
                zfile, zfile_hashvals = save_pdb_zip(pdb_file)

            # save uploaded sdf to tmp storage
            tmp_file = save_tmp_file(myfile)

            task_update = add_cset_mols.s(cset=update_set, target=target, sdf_file=tmp_file, zfile=zfile).apply_async()

            context = {}
            context['update_task_id'] = task_update.id
            context['update_task_status'] = task_update.status

            # Update client side with task id and status
            return render(request, 'viewer/update-cset.html', context)

        context['form'] = form
        return render(request, 'viewer/update-cset.html', context)


class UploadCSet(View):
    """ View to render and control viewer/upload-cset.html  - a page allowing upload of computed sets. Validation and
    upload tasks are defined in `viewer.compound_set_upload`, `viewer.sdf_check` and `viewer.tasks` and the task
    response handling is done by `viewer.views.ValidateTaskView` and `viewer.views.UploadTaskView`

    Methods
    -------
    allowed requests:
        - GET: renders form
        - POST: validates and optionally uploads the computed set that the user provides via the template form
    url:
        viewer/upload_cset
    template:
        viewer/upload-cset.html
    request params:
        - target_name (`django.forms.CharField`): Name of the existing fragalysis target to add the computed set to
        - sdf_file (`django.forms.FileField`): SDF file of all computed molecules to upload for the computed set
        - pdb_zip (`django.forms.FileField`): zip file of apo pdb files referenced in the ref_pdb field for molecules in sdf_file (optional)
        - submit_choice (`django.forms.CharField`): 0 to validate, 1 to validate and upload
        - upload_key (`django.forms.CharField`): users unique upload key, generated by `viewer.views.cset_key`
    context:
        - form (`django.Forms.form`): instance of `viewer.forms.CSetForm`
        - validate_task_id (str): celery task id for validation step
        - validate_task_status (str): celery task status for validation step
        - upload_task_id (str): celery task id for upload step
        - upload_task_status (str): celery task status for upload step

    """

    def get(self, request):

        # test = TargetView().get_queryset(request=request)
        # targets = request.get('/api/targets/')
        # int(targets)
        form = CSetForm()
        existing_sets = ComputedSet.objects.all()
        return render(request, 'viewer/upload-cset.html', {'form': form, 'sets': existing_sets})

    def post(self, request):

        check_services()
        zfile = None
        zfile_hashvals = None
        zf = None
        cset = None
        form = CSetForm(request.POST, request.FILES)
        context = {}
        if form.is_valid():
            # get the upload key
            # key = request.POST['upload_key']
            # all_keys = CSetKeys.objects.all()
            # if it's not valid, return a message
            # if key not in [str(key.uuid) for key in all_keys]:
            #     html = "<br><p>You either didn't provide an upload key, or it wasn't valid. Please try again
            #     (email rachael.skyner@diamond.ac.uk to obtain an upload key)</p>"
            #     return render(request, 'viewer/upload-cset.html', {'form': form, 'table': html})

            # get all of the variables needed from the form
            myfile = request.FILES['sdf_file']
            target = request.POST['target_name']
            choice = request.POST['submit_choice']

            # get update choice
            update_set = request.POST['update_set']

            if 'pdb_zip' in list(request.FILES.keys()):
                pdb_file = request.FILES['pdb_zip']
            else:
                pdb_file = None

            # save uploaded sdf and zip to tmp storage
            tmp_sdf_file = save_tmp_file(myfile)
            if pdb_file:
                tmp_pdb_file = save_tmp_file(pdb_file)
            else:
                tmp_pdb_file = None

            # Settings for if validate option selected
            if str(choice) == '0':
                # Start celery task
                task_validate = validate_compound_set.delay(tmp_sdf_file, target=target, zfile=tmp_pdb_file, update=update_set)

                context = {}
                context['validate_task_id'] = task_validate.id
                context['validate_task_status'] = task_validate.status

                # Update client side with task id and status
                return render(request, 'viewer/upload-cset.html', context)

            # if it's an upload, run the compound set task
            if str(choice) == '1':
                # Start chained celery tasks. NB first function passes tuple
                # to second function - see tasks.py
                task_upload = (
                            validate_compound_set.s(tmp_sdf_file, target=target, zfile=tmp_pdb_file, update=update_set) | process_compound_set.s()).apply_async()

                context = {}
                context['upload_task_id'] = task_upload.id
                context['upload_task_status'] = task_upload.status

                # Update client side with task id and status
                return render(request, 'viewer/upload-cset.html', context)

        context['form'] = form
        return render(request, 'viewer/upload-cset.html', context)
# End Upload Compound set functions


# Upload Target datasets functions
class UploadTSet(View):
    """ View to render and control viewer/upload-tset.html  - a page allowing upload of computed sets. Validation and
    upload tasks are defined in `viewer.target_set_upload`, `viewer.sdf_check` and `viewer.tasks` and the task
    response handling is done by `viewer.views.ValidateTaskView` and `viewer.views.UploadTaskView`

    Methods
    -------
    allowed requests:
        - GET: renders form
        - POST: validates and optionally uploads the computed set that the user provides via the template form
    url:
        viewer/upload_tset
    template:
        viewer/upload-tset.html
    request params:
        - target_name (`django.forms.CharField`): Name of the existing fragalysis target to add the computed set to
        - target_zip (`django.forms.FileField`): zip file of the target dataset
        - submit_choice (`django.forms.CharField`): 0 to validate, 1 to validate and upload
    context:
        - form (`django.Forms.form`): instance of `viewer.forms.TSetForm`
        - validate_task_id (str): celery task id for validation step
        - validate_task_status (str): celery task status for validation step
        - upload_task_id (str): celery task id for upload step
        - upload_task_status (str): celery task status for upload step

    """

    def get(self, request):

        # Only authenticated users can upload files - this can be switched off in settings.py.
        user = self.request.user
        if not user.is_authenticated and settings.AUTHENTICATE_UPLOAD:
            context = {}
            context['error_message'] \
                = 'Only authenticated users can upload files - please navigate to landing page and Login'
            logger.info('- UploadTSet.get - authentication error')
            return render(request, 'viewer/upload-tset.html', context)

        contact_email = ''
        if user.is_authenticated and settings.AUTHENTICATE_UPLOAD:
            contact_email = user.email

        form = TSetForm(initial={'contact_email': contact_email})

        return render(request, 'viewer/upload-tset.html', {'form': form})

    def post(self, request):
        logger.info('+ UploadTSet.post')
        context = {}

        # Only authenticated users can upload files - this can be switched off in settings.py.
        user = self.request.user
        if not user.is_authenticated and settings.AUTHENTICATE_UPLOAD:
            context['error_message'] \
                = 'Only authenticated users can upload files - please navigate to landing page and Login'
            logger.info('- UploadTSet.post - authentication error')
            return render(request, 'viewer/upload-tset.html', context)

        # Check celery/rdis is up and running
        check_services()
        form = TSetForm(request.POST, request.FILES)
        if form.is_valid():
            # get all of the variables needed from the form
            target_file = request.FILES['target_zip']
            target_name = request.POST['target_name']
            choice = request.POST['submit_choice']
            proposal_ref = request.POST['proposal_ref']
            contact_email = request.POST['contact_email']

            # Create /code/media/tmp if does not exist
            media_root = settings.MEDIA_ROOT
            tmp_folder = os.path.join(media_root, 'tmp')
            if not os.path.isdir(tmp_folder):
                os.mkdir(tmp_folder)

            path = default_storage.save('tmp/' + 'NEW_DATA.zip', ContentFile(target_file.read()))
            new_data_file = str(os.path.join(settings.MEDIA_ROOT, path))

            # Settings for if validate option selected
            if str(choice) == '0':
                # Start celery task
                task_validate = validate_target_set.delay(new_data_file, target=target_name, proposal=proposal_ref,
                                                          email=contact_email)

                context = {}
                context['validate_task_id'] = task_validate.id
                context['validate_task_status'] = task_validate.status

                # Update client side with task id and status
                logger.info('- UploadTSet.post.choice == 0')
                return render(request, 'viewer/upload-tset.html', context)

            # if it's an upload, run the validate followed by the upload target set task
            if str(choice) == '1':
                # Start chained celery tasks. NB first function passes tuple
                # to second function - see tasks.py
                task_upload = (validate_target_set.s(new_data_file, target=target_name, proposal=proposal_ref,
                                                     email=contact_email) | process_target_set.s()).apply_async()

                context = {}
                context['upload_task_id'] = task_upload.id
                context['upload_task_status'] = task_upload.status

                # Update client side with task id and status
                logger.info('- UploadTSet.post.choice == 1')
                return render(request, 'viewer/upload-tset.html', context)

        context['form'] = form

        logger.info('- UploadTSet.post')
        return render(request, 'viewer/upload-tset.html', context)


# End Upload Target datasets functions
def email_task_completion(contact_email, message_type, target_name, target_path=None, task_id=None):
    """ Notifiy user of upload completion
    """

    logger.info('+ email_notify_task_completion: ' + message_type + ' ' + target_name)
    email_from = settings.EMAIL_HOST_USER

    if contact_email == '' or not email_from:
        # Only send email if configured.
        return

    if message_type == 'upload-success':
        subject = 'Fragalysis: Target: '+target_name+' Uploaded'
        message = 'The upload of your target data is complete. Your target is available at: ' \
                  + str(target_path)
    elif message_type == 'validate-success':
        subject = 'Fragalysis: Target: '+target_name+' Validation'
        message = 'Your data was validated. It can now be uploaded using the upload option.'
    else:
        # Validation failure
        subject = 'Fragalysis: Target: ' + target_name + ' Validation/Upload Failed'
        message = 'The validation/upload of your target data did not complete successfully. ' \
                  'Please navigate the following link to check the errors: validate_task/' + str(task_id)

    recipient_list = [contact_email, ]
    logger.info('+ email_notify_task_completion email_from: ' + email_from )
    logger.info('+ email_notify_task_completion subject: ' + subject )
    logger.info('+ email_notify_task_completion message: ' + message )
    logger.info('+ email_notify_task_completion contact_email: ' + contact_email )

    # Send email - this should not prevent returning to the screen in the case of error.
    send_mail(subject, message, email_from, recipient_list, fail_silently=True)
    logger.info('- email_notify_task_completion')
    return


# Task functions common between Compound Sets and Target Set pages.
class ValidateTaskView(View):
    """ View to handle dynamic loading of validation results from `viewer.tasks.validate` - the validation of files
    uploaded to viewer/upload_cset or a target set by a user at viewer/upload_tset

    Methods
    -------
    allowed requests:
        - GET: takes a task id, checks it's status and returns the status, and result if the task is complete
    url:
        validate_task/<validate_task_id>
    template:
        viewer/upload-cset.html or viewer/upload-tset.html
    """
    def get(self, request, validate_task_id):
        """ Get method for `ValidateTaskView`. Takes a validate task id, checks it's status and returns the status,
        and result if the task is complete

        Parameters
        ----------
        request: request
            Context sent by `UploadCSet` or `UploadTset`
        validate_task_id: str
            task id provided by `UploadCSet` or `UploadTset`

        Returns
        -------
        response_data: JSON
            response data (dict) in JSON format:
                - if status = 'RUNNING':
                    - validate_task_status (str): task.status
                    - validate_task_id (str): task.id
                - if status = 'FAILURE':
                    - validate_task_status (str): task.status
                    - validate_task_id (str): task.id
                    - validate_traceback (str): task.traceback
                - if status = 'SUCCESS':
                    - validate_task_status (str): task.status
                    - validate_task_id (str): task.id
                    - html (str): html of task outcome - success message or html table of errors & fail message

        """
        logger.info('+ ValidateTaskView.get')
        task = AsyncResult(validate_task_id)
        response_data = {'validate_task_status': task.status,
                         'validate_task_id': task.id}

        if task.status == 'FAILURE':
            logger.info('+ ValidateTaskView.get.FAILURE')
            result = task.traceback
            response_data['validate_traceback'] = str(result)

            return JsonResponse(response_data)

        # Check if results ready
        if task.status == "SUCCESS":
            logger.info('+ ValidateTaskView.get.SUCCESS')
            results = task.get()
            # NB get tuple from validate task
            process_type = results[1]
            validate_dict = results[2]
            validated = results[3]
            if validated:
                response_data['html'] = 'Your data was validated. \n It can now be uploaded using the upload option.'
                response_data['validated'] = 'Validated'

                if process_type== 'tset':
                    target_name = results[5]
                    contact_email = results[8]
                    email_task_completion(contact_email, 'validate-success', target_name)

                return JsonResponse(response_data)

            if not validated:
                # set pandas options to display all column data
                pd.set_option('display.max_colwidth', -1)

                table = pd.DataFrame.from_dict(validate_dict)
                html_table = table.to_html()
                html_table += '''<p> Your data was <b>not</b> validated. The table above shows errors</p>'''

                response_data["html"] = html_table
                response_data['validated'] = 'Not validated'
                if process_type== 'tset':
                    target_name = results[5]
                    contact_email = results[8]
                    email_task_completion(contact_email, 'validate-failure', target_name, task_id=validate_task_id)

                return JsonResponse(response_data)

        return JsonResponse(response_data)


class UpdateTaskView(View):

    def get(self, request, update_task_id):
        task = AsyncResult(update_task_id)
        response_data = {'update_task_status': task.status,
                         'update_task_id': task.id}

        result = 'Running...'

        if task.status == 'FAILURE':
            result = task.traceback
            response_data['result'] = str(result)

        if task.status == 'SUCCESS':
            result = task.get()

        response_data['result'] = str(result)

        return JsonResponse(response_data)


class UploadTaskView(View):
    """ View to handle dynamic loading of upload results from `viewer.tasks.process_compound_set` - the upload of files
    for a computed set by a user at viewer/upload_cset or a target set by a user at viewer/upload_tset

    Methods
    -------
    allowed requests:
        - GET: takes a task id, checks it's status and returns the status, and result if the task is complete
    url:
        upload_task/<uploads_task_id>
    template:
        viewer/upload-cset.html or viewer/upload-tset.html
    """
    def get(self, request, upload_task_id):
        """ Get method for `UploadTaskView`. Takes an upload task id, checks it's status and returns the status,
        and result if the task is complete

        Parameters
        ----------
        request: request
            Context sent by `UploadCSet` or `UploadTSet`
        upload_task_id: str
            task id provided by `UploadCSet` or `UploadTSet`

        Returns
        -------
        response_data: JSON
            response data (dict) in JSON format:
                - if status = 'RUNNING':
                    - upload_task_status (str): task.status
                    - upload_task_id (str): task.id
                - if status = 'FAILURE':
                    - upload_task_status (str): task.status
                    - upload_task_id (str): task.id
                    - upload_traceback (str): task.traceback
                - if status = 'SUCCESS':
                    - upload_task_status (str): task.status
                    - upload_task_id (str): task.id
                    - if results are a list (data was processed - validated or uploaded):
                        if this was a validation process
                        - validated (str): 'Not validated'
                        - html (str): html table of validation errors
                        if results are a validation/upload process:
                        - validated (str): 'Validated'
                        - results (dict): results
                        For compound sets ('cset')
                        - results['cset_download_url'] (str): download url for computed set sdf file
                        - results['pset_download_url'] (str): download url for computed set pdb files (zip)
                        For target sets ('tset')
                        - results['tset_download_url'] (str): download url for processed zip file
                    - if results are not string or list:
                        - processed (str): 'None'
                        - html (str): message to tell the user their data was not processed

        """
        logger.info('+ UploadTaskView.get')
        task = AsyncResult(upload_task_id)
        response_data = {'upload_task_status': task.status,
                         'upload_task_id': task.id}

        if task.status == 'FAILURE':
            result = task.traceback
            response_data['upload_traceback'] = str(result)

            return JsonResponse(response_data)

        if task.status == 'SUCCESS':
            logger.info('+ UploadTaskView.get.success')

            results = task.get()

            # Validation output for a cset or tset is a dictionary.
            if isinstance(results, list):
                if results[0] == 'validate':
                    # Get dictionary results
                    validate_dict = results[1]

                    # set pandas options to display all column data
                    pd.set_option('display.max_colwidth', -1)
                    table = pd.DataFrame.from_dict(results[2])
                    html_table = table.to_html()
                    html_table += '''<p> Your data was <b>not</b> validated. The table above shows errors</p>'''

                    response_data['validated'] = 'Not validated'
                    response_data['html'] = html_table

                    return JsonResponse(response_data)
                else:
                    # Upload/Update output tasks send back a tuple
                    # First element defines the source of the upload task (cset, tset)
                    response_data['validated'] = 'Validated'
                    if results[1] == 'tset':
                        target_name = results[2]
                        contact_email = results[5]
                        target_path = '/viewer/target/%s' % target_name
                        response_data['results'] = {}
                        response_data['results']['tset_download_url'] = target_path
                        logger.info('+ UploadTaskView.get.success -email:'+contact_email)
                        email_task_completion(contact_email, 'upload-success', target_name, target_path=target_path)
                    else:
                        cset_name = results[2]
                        cset = ComputedSet.objects.get(name=cset_name)
                        submitter = cset.submitter
                        name = cset.unique_name
                        response_data['results'] = {}
                        response_data['results']['cset_download_url'] = '/viewer/compound_set/%s' % name
                        response_data['results']['pset_download_url'] = '/viewer/protein_set/%s' % name

                    return JsonResponse(response_data)

            else:
                # Error output
                html_table = '''<p> Your data was <b>not</b> processed.</p>'''
                response_data['processed'] = 'None'
                response_data['html'] = html_table
                return JsonResponse(response_data)

        return JsonResponse(response_data)
# End Task functions which hopefully can be common between Compound Sets and Target Set pages.


def img_from_smiles(request):
    """ View to generate a 2D molecule image for a given smiles string

    Methods
    -------
    allowed requests:
        - GET: generate a 2D molecule image for a given smiles string
    url:
        viewer/img_from_smiles
    request params:
        - smiles (str): smiles string to generate image for

    Returns
    -------
    HTTPResponse (str):
        - if smiles provided:
            string for SVG image of molecule
        - if smiles not provided:
            "Please insert SMILES"

    """
    if "smiles" in request.GET:
        smiles = request.GET["smiles"]
        if smiles:
            return get_params(smiles, request)
        else:
            return HttpResponse("Please insert SMILES")
    else:
        return HttpResponse("Please insert SMILES")


def highlight_mol_diff(request):
    """ View to generate a 2D molecule image highlighting the difference between a reference and new molecule

    Methods
    -------
    allowed requests:
        - GET: generate a 2D molecule image highlighting the difference between a reference and new molecule
    url:
        viewer/highlight_mol_diff
    request params:
        - prb_smiles (str): smiles string to generate image for
        - ref_smiles (str): reference smiles for highlighting by MCS

    Returns
    -------
    HTTPResponse (str):
        - if smiles provided:
            string for SVG image of molecule
        - if smiles not provided:
            "Please insert smiles for reference and probe"

    """
    if 'prb_smiles' and 'ref_smiles' in request.GET:
        return HttpResponse(get_highlighted_diffs(request))
    else:
        return HttpResponse("Please insert smiles for reference and probe")


def similarity_search(request):
    if "smiles" in request.GET:
        smiles = request.GET["smiles"]
    else:
        return HttpResponse("Please insert SMILES")
    if "db_name" in request.GET:
        db_name = request.GET["db_name"]
    else:
        return HttpResponse("Please insert db_name")
    sql_query = """SELECT sub.*
  FROM (
    SELECT rdk.id,rdk.structure,rdk.idnumber
      FROM vendordbs.enamine_real_dsi_molfps AS mfp
      JOIN vendordbs.enamine_real_dsi AS rdk ON mfp.id = rdk.id
      WHERE m @> qmol_from_smiles(%s) LIMIT 1000
  ) sub;"""
    with connections[db_name].cursor() as cursor:
        cursor.execute(sql_query, [smiles])
        return HttpResponse(json.dumps(cursor.fetchall()))


def get_open_targets(request):
    """ View to return a list of all open targets

    Methods
    -------
    allowed requests:
        - GET: return a list of all open targets
    url:
        viewer/open_targets
    request params:
        None

    Returns
    -------
    HTTPResponse (JSON/dict):
        - target_names (list): list of open targets
        - target_ids (list): list of ids for open targets in same order as target_names

    """
    targets = Target.objects.all()
    target_names = []
    target_ids = []

    for t in targets:
        for p in t.project_id.all():
            if 'OPEN' in p.title:
                target_names.append(t.title)
                target_ids.append(t.id)

    return HttpResponse(json.dumps({'target_names': target_names, 'target_ids': target_ids}))


# This is used in the URL on the process results page after uploading a compound_set
def cset_download(request, name):
    """ View to download an SDF file of a computed set by name

    Methods
    -------
    allowed requests:
        - GET: return the SDF file as a download
    url:
        viewer/compound_set/(<name>)
    request params:
        - name (str): the name of the computed set to download

    Returns
    -------
    Response (attachment; text/plain):
        - <name>.sdf: sdf file for the computed set

    """
    compound_set = ComputedSet.objects.get(unique_name=name)
    filepath = compound_set.submitted_sdf
    with open(filepath.path, 'r') as fp:
        data = fp.read()
    filename = 'compund-set_' + name + '.sdf'
    response = HttpResponse(content_type='text/plain')
    response['Content-Disposition'] = 'attachment; filename=%s' % filename  # force browser to download file
    response.write(data)
    return response


def pset_download(request, name):
    """ View to download a zip file of all protein structures (apo) for a computed set

     Methods
     -------
     allowed requests:
         - GET: return the zip file as a download
     url:
         viewer/compound_set/(<name>)
     request params:
         - name (str): the name of the computed set to download

     Returns
     -------
     Response (attachment; application/zip):
         - <name>.zip: zip file for the computed set

     """
    response = HttpResponse(content_type='application/zip')
    filename = 'protein-set_' + name + '.zip'
    response['Content-Disposition'] = 'filename=%s' % filename  # force browser to download file

    compound_set = ComputedSet.objects.get(unique_name=name)
    computed = ComputedMolecule.objects.filter(computed_set=compound_set)
    pdb_filepaths = list(set([c.pdb_info.path for c in computed]))

    buff = StringIO()
    zip_obj = zipfile.ZipFile(buff, 'w')

    for fp in pdb_filepaths:
        data = open(fp, 'r').read()
        zip_obj.writestr(fp.split('/')[-1], data)
    zip_obj.close()

    buff.flush()
    ret_zip = buff.getvalue()
    buff.close()
    response.write(ret_zip)

    return response


# This is used in the URL on the process results page after uploading a target_set
def tset_download(request, title):
    """ View to download an zip file of a target set by name

    Methods
    -------
    allowed requests:
        - GET: return the zip file as a download
    url:
        viewer/target/(<title>)
    request params:
        - title (str): the title of the target set to download

    Returns
    -------
    Response (attachment; text/plain):
        - <title>.zip: zip file for the target set

    """
    target_set = Target.objects.get(title=title)
    media_root = settings.MEDIA_ROOT
    filepath = os.path.join(media_root, target_set.zip_archive.name)
    target_zip = open(filepath, 'rb')
    filename = 'target-set_' + title + '.zip'
    response = HttpResponse(target_zip, content_type='application/force-download')
    response['Content-Disposition'] = 'attachment; filename="%s"' % filename  # force browser to download file
    return response


# Start of ActionType
class ActionTypeView(viewsets.ModelViewSet):
    """ Djagno view to retrieve information about action types available to users (GET)

    Methods
    -------
    url:
        api/action-types
    queryset:
        `viewer.models.ActionType.objects.filter()`
    methods:
        `get, head`
    filter fields:
        - `viewer.models.ActionType.description` - ?description=<str>
        - `viewer.models.ActionType.active` - ?active=<boolean>
        - `viewer.models.ActionType.activation_date` - ?date=<str>

    returns: JSON
        - id: id of the action type
        - description: The description of the action type
        - active: True if action type is active, False if not
        - activation_date: The datetime the action type became active

    example output:

        .. code-block:: javascript

            "results": [
                {
                    "id": 1,
                    "description": "Test Action TYpe",
                    "active": true,
                    "activation_date": "2020-10-06T14:42:00Z"
                }
            ]

   """
    queryset = ActionType.objects.filter()
    serializer_class = ActionTypeSerializer

    # POST method allowed for flexibility in the PoC. In the final design we may want to prevent the POST/PUT methods
    # from being used
    # for action types so that these can only be updated via the admin panel.
    #    http_method_names = ['get', 'head']

    filter_fields = '__all__'


# Start of Session Project
class SessionProjectsView(viewsets.ModelViewSet):
    """ Djagno view to retrieve information about user projects (collection of sessions) (GET). Also used for saving
    project information (PUT, POST, PATCH)

    Methods
    -------
    url:
        api/session-projects
    queryset:
        `viewer.models.SessionProject.objects.filter()`
    filter fields:
        - `viewer.models.SessionProject.title` - ?title=<str>
        - `viewer.models.SessionProject.init_date` - ?date=<str>
        - `viewer.models.SessionProject.description` - ?description=<str>
        - `viewer.models.SessionProject.target` - ?target=<int>
        - `viewer.models.SessionProject.author` - ?author=<str>
        - `viewer.models.SessionProject.tags` - ?tags=<list>
    returns: JSON
        - id: id of the project
        - target: dict of target info:
            - id: target id
            - title: name of the target protein
            - project_id: id of the project
            - protein_set: list of protein objects associated with the target
            - template_protein: link to the file used as the reference in fragalysis frontend
            - metadata: link to the target metadata file
            - zip_archive: link to the zip archive of uploaded files
        - author: name of the author that created the session
        - title: title for the project
        - init_date: timestamp for when the project was created
        - description: author defined description of the project
        - tags: list of tags given to the project by the author

    example output:

        .. code-block:: javascript

            "results": [
            {
                "id": 122,
                "target": {
                    "id": 62,
                    "title": "Mpro",
                    "project_id": [
                        2
                    ],
                    "protein_set": [
                        29281,
                        29274,
                        29259,
                        29305,
                        29250,
                        ...,
                    ],
                    "template_protein": "/media/pdbs/Mpro-x10417_0_apo.pdb",
                    "metadata": "http://fragalysis.diamond.ac.uk/media/metadata/metadata_2FdP5OJ.csv",
                    "zip_archive": "http://fragalysis.diamond.ac.uk/media/targets/Mpro.zip"
                },
                "author": null,
                "title": "READ_ONLY",
                "init_date": "2020-07-09T19:52:10.506119Z",
                "description": "READ_ONLY",
                "tags": "[]"
            },]

   """
    queryset = SessionProject.objects.filter()

    def get_serializer_class(self):
        """Determine which serializer to use based on whether the request is a GET or a POST, PUT or PATCH request

        Returns
        -------
        Serializer (rest_framework.serializers.ModelSerializer):
            - if GET: `viewer.serializers.SessionProjectReadSerializer`
            - if other: `viewer.serializers.SessionProjectWriteSerializer`
        """
        if self.request.method in ['GET']:
            # GET
            return SessionProjectReadSerializer
        # (POST, PUT, PATCH)
        return SessionProjectWriteSerializer

    filter_permissions = "target_id__project_id"
    filter_fields = '__all__'


class SessionActionsView(viewsets.ModelViewSet):
    """ Djagno view to retrieve information about actions relating to sessions_project (GET). Also used for saving
    project action information (PUT, POST, PATCH)

    Methods
    -------
    url:
        api/session-actions
    queryset:
        `viewer.models.SessionActions.objects.filter()`
    filter fields:
        - `viewer.models.SessionProject.author` - ?author=<str>
        - `viewer.models.SessionProject.session_project` - ?project=<str>
        - `viewer.models.SessionProject.last_update_date` - ?date=<str>

    returns: JSON
        - id: id of the session action record
        - author: id of the user that created the session_project
        - session_project: id of the related session_project
        - last_update_date: Timestamp for when the action list was generated or updated
        - actions: JSON string containing actions related to the session_project

    example output:

        .. code-block:: javascript

            "results": [
                {
                    "id": 1,
                    "last_update_date": "2020-10-06T15:36:00Z",
                    "actions": {
                        "save": false,
                        "show": true,
                        "action_type": 1,
                        "object_name": "",
                        "object_type": "",
                        "action_datetime": "2020-09-30T13:44:00.000Z"
                    },
                    "author": 1,
                    "session_project": 1,
                }
            ]

   """
    queryset = SessionActions.objects.filter()
    serializer_class = SessionActionsSerializer

    #   Note: jsonField for Actions will need specific queries - can introduce if needed.
    filter_fields = ('id', 'author', 'session_project', 'last_update_date')


class SnapshotsView(viewsets.ModelViewSet):
    """ Djagno view to retrieve information about user sessions (snapshots) (GET). Also used for saving
    session information (PUT, POST, PATCH)

    Methods
    -------
    url:
        api/snapshots
    queryset:
        `viewer.models.Snapshot.objects.filter()`
    filter class:
        `viewer.filters.SnapshotFilter`
    filter fields:
        - `viewer.models.Snapshot.id` - ?id=<int>
        - `viewer.models.Snapshot.type` - ?type=<str>
        - `viewer.models.Snapshot.author` - ?author=<str>
        - `viewer.models.Snapshot.description` ?description=<str>
        - `viewer.models.Snapshot.created` - ?created=<str>
        - `viewer.models.Snapshot.data` - ?data=<JSON str>
        - `viewer.models.Snapshot.session_project_id` - ?session_project_id=<int>
        - `viewer.models.Snapshot.parent` - ?parent=<int>
        - `viewer.models.Snapshot.children` - ?children=<list>
        - `viewer.models.Snapshot.session_project` - ?session_project=<int>
    returns: JSON
        - id: id of the snapshot
        - type: type of snapshot
        - title: title of snapshot given by author
        - description: description of the snapshot given by author
        - created: timestamp for when the snapshot was created
        - data: json string describing data needed to reproduce state of the snapshot by the front-end
        - session_project: dict describing the project that the snapshot belongs to:
            - id: project id
            - title: project title
            - init_data: timestamp for when the project was initiated
            - description: description of the project given by the author
            - tags: tags given to the project by the author
            - target: id of the target that the project is associated with
            - author: name of the author who created the project
        - parent: parent snapshot id of the current snapshot
        - children: list of children ids of the current snapshot

    example output:

        .. code-block:: javascript

            "results": [
                {
                    "id": 132,
                    "type": "INIT",
                    "title": "-- 2020-07-09 -- 16:01:35",
                    "author": null,
                    "description": "Snapshot generated by anonymous user",
                    "created": "2020-07-09T20:01:36.901552Z",
                    "data": '"{\"apiReducers\":{\"target_id_list\":[{\"id\":2,\"title\":\"NUDT7A\",\'
                    "session_project": {
                        "id": 124,
                        "title": "READ_ONLY",
                        "init_date": "2020-07-09T20:01:35.715324Z",
                        "description": "READ_ONLY",
                        "tags": "[]",
                        "target": 62,
                        "author": null
                    },
                    "parent": null,
                    "children": []
                },]

   """
    queryset = Snapshot.objects.filter()

    def get_serializer_class(self):
        """Determine which serializer to use based on whether the request is a GET or a POST, PUT or PATCH request

        Returns
        -------
        Serializer (rest_framework.serializers.ModelSerializer):
            - if GET: `viewer.serializers.SnapshotReadSerializer`
            - if other: `viewer.serializers.SnapshotWriteSerializer`
        """
        if self.request.method in ['GET']:
            return SnapshotReadSerializer
        return SnapshotWriteSerializer

    filter_class = filters.SnapshotFilter


class SnapshotActionsView(viewsets.ModelViewSet):
    """ Djagno view to retrieve information about actions relating to snapshots (GET). Also used for saving
    snapshot action information (PUT, POST, PATCH)

    Methods
    -------
    url:
        api/snapshot-actions
    queryset:
        `viewer.models.SnapshotActions.objects.filter()`
    filter fields:
        - `viewer.models.SnapshotActions.snapshot` - ?snapshot=<str>
        - `viewer.models.SnapshotActions.last_update_date` - ?date=<str>

    returns: JSON
        - id: id of the snapshot action record
        - author: id of the user that created the snapshot
        - session_project: id of the related session_project (if present)
        - snapshot: id of the related snapshot
        - last_update_date: Timestamp for when the action list was generated or updated
        - actions: JSON string containing actions related to the session_project

    example output:

        .. code-block:: javascript

            "results": [
                {
                    "id": 1,
                    "last_update_date": "2020-10-06T15:36:00Z",
                    "actions": {
                        "save": false,
                        "show": true,
                        "action_type": 1,
                        "object_name": "",
                        "object_type": "",
                        "action_datetime": "2020-09-30T13:44:00.000Z"
                    },
                    "author": 1,
                    "session_project": 1,
                    "snapshot": 1
                }
            ]

   """
    queryset = SnapshotActions.objects.filter()
    serializer_class = SnapshotActionsSerializer

    #   Note: jsonField for Actions will need specific queries - can introduce if needed.
    filter_fields = ('id', 'author', 'session_project', 'snapshot', 'last_update_date')

# End of Session Project


# Design sets upload
# Custom parser class for a csv file
class DSetCSVParser(BaseParser):
    """
    CSV parser class specific to design set csv spec - sets media_type for DSetUploadView to text/csv
    """
    media_type = 'text/csv'


class DSetUploadView(APIView):
    """DjangoRF view to upload a design set (PUT) from a csv file

    Methods
    -------
    allowed requests:
        - PUT: takes a csv file and uploads it as a design set (of 2D compounds)
    url:
       viewer/upload_designs
    request params:
        - file (csv file): csv file containing design set information
        - type (str): design set type (options in `viewer.models.DesignSet.set_type`)
        - description (str): short description of the design set - e.g. method of creation
    csv file columns (mandatory):
        - set_name - the name of the design set to upload the molecule to
        - smiles - smiles string for the 2D molecule
        - identifier - an identifier for the molecule
        - inspirations - inspiration molecules from fragalysis used in the design of the 2D molecule

    Returns
    -------
    HTTPResponse (JSON (string))
        A message telling the user whether the upload was successful or not

    """
    parser_class = (DSetCSVParser,)

    def put(self, request, format=None):
        """Method to handle PUT request and upload a design set
        """

        f = request.FILES['file']
        set_type = request.PUT['type']
        set_description = request.PUT['description']

        # save uploaded file to temporary storage
        name = f.name
        path = default_storage.save('tmp/' + name, ContentFile(f.read()))
        tmp_file = str(os.path.join(settings.MEDIA_ROOT, path))

        df = pd.read_csv(tmp_file)
        mandatory_cols = ['set_name', 'smiles', 'identifier', 'inspirations']
        actual_cols = df.columns
        for col in mandatory_cols:
            if col not in actual_cols:
                raise ParseError("The 4 following columns are mandatory: set_name, smiles, identifier, inspirations")

        set_names, compounds = process_design_sets(df, set_type, set_description)

        string = 'Design set(s) successfully created: '

        length = len(set_names)
        string += str(length) + '; '
        for i in range(0, length):
            string += str(i + 1) + ' - ' + set_names[i] + ') number of compounds = ' + str(len(compounds[i])) + '; '

        return HttpResponse(json.dumps(string))


class ComputedSetView(viewsets.ReadOnlyModelViewSet):
    """ DjagnoRF view to retrieve information about computed sets

    Methods
    -------
    url:
        api/compound-sets
    queryset:
        `viewer.models.ComputedSet.objects.filter()`
    filter fields:
        - `viewer.models.ComputedSet.target` - ?target=<int>
    returns: JSON
        - name: name of the computed set
        - submitted_sdf: link to the uploaded sdf file
        - spec_version: version of the upload specification used to generate the computed set sdf
        - method_url: link to url describing the methodology used to create the computed set
        - unique_name: auto-generated human-readable name for the computed set
        - target: id for the associated target
        - submitter: id for the associated submitter

    example output:

        .. code-block:: javascript

            "results": [
                {
                    "name": "100threehop2020-07-27S8vv3vx",
                    "submitted_sdf": "http://fragalysis.diamond.ac.uk/media/code/media/compound_sets/Top_100_three_hop_2020-07-27_S8vv3vx.sdf",
                    "spec_version": 1.2,
                    "method_url": "https://github.com/Waztom/xchem-xCOS",
                    "unique_name": "WT-xCOS2-ThreeHop",
                    "target": 62,
                    "submitter": 13
                },]

    """
    queryset = ComputedSet.objects.filter()
    serializer_class = ComputedSetSerializer
    filter_permissions = "project_id"
    filter_fields = ('target', 'target__title')


class ComputedMoleculesView(viewsets.ReadOnlyModelViewSet):
    """ DjagnoRF view to retrieve information about computed molecules - 3D info

    Methods
    -------
    url:
        api/compound-molecules
    queryset:
        `viewer.models.ComputedMolecule.objects.filter()`
    filter fields:
        - `viewer.models.ComputedMolecule.computed_set` - ?computed_set=<int>
    returns: JSON
        - id: id of the molecule
        - sdf_info: 3D coordinates of the molecule in MDL format
        - name: a name for the molecule
        - smiles: SMILES string
        - pdb_info: link to the associated pdb file (apo)
        - compound: id for the associated 2D compound
        - computed_set: name for the associated computed set
        - computed_inspirations: list of ids for the inspirations used in the design/computation of the molecule

    example output:

        .. code-block:: javascript

            "results": [
                {
                    "id": 1997,
                    "sdf_info": "FRA-DIA-8640f307-1    RDKit          3D 38 42  0  0  0  0  0  0  0  0999 V2000..."
                    "name": "FRA-DIA-8640f307-1",
                    "smiles": "CC(=O)NCCc1c[nH]c2c([C@H](CN(Cc3cc(C)on3)C(=O)NC3CC3)c3nnc(C)s3)cc(F)cc12",
                    "pdb_info": "http://fragalysis.diamond.ac.uk/media/pdbs/Fragmenstein_J6Sfvrs.pdb",
                    "compound": 4030,
                    "computed_set": "100XCOS2Teo2020-07-23yuZJZFY",
                    "computed_inspirations": []
                },]


    """
    queryset = ComputedMolecule.objects.filter()
    serializer_class = ComputedMoleculeSerializer
    filter_permissions = "project_id"
    filter_fields = ('computed_set',)


class NumericalScoresView(viewsets.ReadOnlyModelViewSet):
    """ DjagnoRF view to retrieve information about numerical computed molecule scores

    Methods
    -------
    url:
        api/numerical-scores
    queryset:
        `viewer.models.NumericalScoreValues.objects.filter()`
    filter fields:
        - `viewer.models.NumericalScoreValues.compound` - ?compound=<int>
        - `viewer.models.NumericalScoreValues.score` - ?score=<int>
    returns: JSON
        - id: id of the score
        - score: dict of the score info:
            - id: id of the score description
            - name: name of the score
            - description: description of the score
            - computed_set: name of the computed set that the score is associated to
        - value: numerical value of the score
        - compound: id of the associated compound object

    example output:

        .. code-block:: javascript

            "results": [
                "results": [
                    {
                        "id": 8145,
                        "score": {
                            "id": 48,
                            "name": "Score_1",
                            "description": "The score is scaled by the number of bit atoms",
                            "computed_set": "100XCOS2Teo2020-07-23yuZJZFY"
                        },
                        "value": 19.8653,
                        "compound": 1997
                    },


    """

    queryset = NumericalScoreValues.objects.filter()
    serializer_class = NumericalScoreSerializer
    filter_permissions = "project_id"
    filter_fields = ('compound', 'score')


class TextScoresView(viewsets.ReadOnlyModelViewSet):
    """ DjagnoRF view to retrieve information about text computed molecule scores

    Methods
    -------
    url:
        api/text-scores
    queryset:
        `viewer.models.TextScoreValues.objects.filter()`
    filter fields:
        - `viewer.models.TextScoreValues.compound` - ?compound=<int>
        - `viewer.models.TextScoreValues.score` - ?score=<int>
    returns: JSON
        - id: id of the score
        - score: dict of the score info:
            - id: id of the score description
            - name: name of the score
            - description: description of the score
            - computed_set: name of the computed set that the score is associated to
        - value: text value of the score
        - compound: id of the associated compound object

    example output:

        .. code-block:: javascript

            "results": [
                "results": [
                    {
                        "id": 8145,
                        "score": {
                            "id": 48,
                            "name": "Score_1",
                            "description": "Desctription",
                            "computed_set": "100XCOS2Teo2020-07-23yuZJZFY"
                        },
                        "value": "Yes",
                        "compound": 1997
                    },


    """
    queryset = TextScoreValues.objects.filter()
    serializer_class = TextScoreSerializer
    filter_permissions = "project_id"
    filter_fields = ('compound', 'score')


class CompoundScoresView(viewsets.ReadOnlyModelViewSet):
    """ DjagnoRF view to retrieve descriptions of scores for a given name or computed set

    Methods
    -------
    url:
        api/compound-scores
    queryset:
        `viewer.models.ScoreDescription.objects.filter()`
    filter fields:
        - `viewer.models.ScoreDescription.computed_set` - ?computed_set=<int>
        - `viewer.models..ScoreDescription.name` - ?name=<str>
    returns: JSON
        - id: id of the score
        - score: dict of the score info:
            - id: id of the score description
            - name: name of the score
            - description: description of the score
            - computed_set: name of the computed set that the score is associated to

    example output:

        .. code-block:: javascript

            "results": [
                {
                    "id": 22,
                    "name": "FeatureSteinScore",
                    "description": "FeatureStein Score",
                    "computed_set": "top26062020axX6Vqt"
                },]


    """
    queryset = ScoreDescription.objects.filter()
    serializer_class = ScoreDescriptionSerializer
    filter_permissions = "project_id"
    filter_fields = ('computed_set', 'name')


class ComputedMolAndScoreView(viewsets.ReadOnlyModelViewSet):
    """ DjagnoRF view to retrieve all information about molecules from a computed set, along with all of their scores

    Methods
    -------
    url:
        api/compound-mols-scores
    queryset:
        `viewer.models.ComputedMolecule.objects.filter()`
    filter fields:
        - `viewer.models.ComputedMolecule.computed_set` - ?computed_set=<int>
    returns: JSON
        - id: id of the molecule
        - sdf_info: 3D coordinates of the molecule in MDL format
        - name: a name for the molecule
        - smiles: SMILES string
        - pdb_info: link to the associated pdb file (apo)
        - compound: id for the associated 2D compound
        - computed_set: name for the associated computed set
        - computed_inspirations: list of ids for the inspirations used in the design/computation of the molecule
        - numerical_scores: dict of numerical scores, where each key is a name, and each value is the associated score
        - text_scores: dict of text scores, where each key is a score name, and each value is the associated score

    example output:

        .. code-block:: javascript

            "results": [
                {
                    "id": 1997,
                    "sdf_info": "FRA-DIA-8640f307-1     RDKit          3D 38 42  0  0  0  0  0  0  0"
                    "name": "FRA-DIA-8640f307-1",
                    "smiles": "CC(=O)NCCc1c[nH]c2c([C@H](CN(Cc3cc(C)on3)C(=O)NC3CC3)c3nnc(C)s3)cc(F)cc12",
                    "pdb_info": "http://fragalysis.diamond.ac.uk/media/pdbs/Fragmenstein_J6Sfvrs.pdb",
                    "compound": 4030,
                    "computed_set": "100XCOS2Teo2020-07-23yuZJZFY",
                    "computed_inspirations": [],
                    "numerical_scores": {
                        "Score_1": 19.8653,
                        "N_hits": 4.0
                    },
                    "text_scores": {}
                },]


    """
    queryset = ComputedMolecule.objects.filter()
    serializer_class = ComputedMolAndScoreSerializer
    filter_permissions = "project_id"
    filter_fields = ('computed_set',)


class DiscoursePostView(viewsets.ViewSet):
    """Django view to get and post to the Discourse platform

    Methods
    -------
    allowed requests:
        - POST: Takes a post and calls a function to post the details to the Discourse platform.
        - GET: (No yet fully operational - returns posts for ?post_title=<topic title>
    url:
       api/discourse_post
    params:
        - category_name: sub category_name for Discourse post (optional if post title is given)
        - parent_category_name: Discourse parent_category name - defaults to "Fragalysis targets" (Setting)
        - category_colour: Optional - defaults to '0088CC'
        - category_text_colour: Optional defaults to 'FFFFFF'
        - post_title: title of topic or post (optional if category name is given)
        - post_content: content of the post
        - post_tags: a JSON string of tags related to the Post

    Returns JSON

    example of input (GET) on local:

        http://127.0.0.1:8080/api/discourse_post/?post_title=Mpro%20First%20Project

    examples of input (POST raw data):

        {"category_name": "NewCategory", "parent_category_name": "Fragalysis targets", "category_colour": "0088CC",
        "category_text_colour": "FFFFFF", "post_title": "", "post_content": "", "post_tags":""}

        {"category_name": "NewCategory", "parent_category_name": "Fragalysis targets", "category_colour": "0088CC",
        "category_text_colour": "FFFFFF", "post_title": "New Topic Title 1",
        "post_content": "This is the first post that creates the topic - must be greater than 20 chars",
        "post_tags" :"[\\"tag1\\",\\"tag2\\"]"}

        {"category_name": "NewCategory", "parent_category_name": "Fragalysis targets", "category_colour": "0088CC",
        "category_text_colour": "FFFFFF", "post_title": "New Topic Title 1",
        "post_content": "This is a second post to New Topic Title 1", "post_tags" :"[]"}

    example output (POST):

        .. code-block:: javascript

          {
                "Post url": "https://discourse.xchem-dev.diamond.ac.uk/t/78/1"
          }

    example output (GET):

        .. code-block:: javascript

            {
                "Posts": {
                    "post_stream": {
                        "posts": [
                            {
                                "id": 131,
                                "name": "user",
                                "username": "user",
                                "avatar_template": "/letter_avatar_proxy/v4/letter/u/c0e974/{size}.png",
                                "created_at": "2020-12-10T14:50:56.006Z",
                                "cooked": "<p>This is a post for session-project 0005 to test if it works without parent category</p>",
                                "post_number": 1,
                                "post_type": 1,
                                "updated_at": "2020-12-10T14:50:56.006Z",
                                "reply_count": 0,
                                "reply_to_post_number": null,
                                "quote_count": 0,
                                "incoming_link_count": 1,
                                "reads": 1,
                                "readers_count": 0,
                                "score": 5.2,
                                "yours": true,
                                "topic_id": 81,
                                "topic_slug": "api-test-session-project-000005",
                                "display_username": "user",
                                "primary_group_name": null,
                                "primary_group_flair_url": null,
                                "primary_group_flair_bg_color": null,
                                "primary_group_flair_color": null,
                                "version": 1,
                                "can_edit": true,
                                "can_delete": false,
                                "can_recover": false,
                                "can_wiki": true,
                                "read": true,
                                "user_title": null,
                                "actions_summary":
                                [
                                    {
                                        "id": 3,
                                        "can_act": true
                                    },
                                    {
                                        "id": 4,
                                        "can_act": true
                                    },
                                    {
                                        "id": 8,
                                        "can_act": true
                                    },
                                    {
                                        "id": 7,
                                        "can_act": true
                                    }
                                ],
                                "moderator": false,
                                "admin": true,
                                "staff": true,
                                "user_id": 1,
                                "hidden": false,
                                "trust_level": 1,
                                "deleted_at": null,
                                "user_deleted": false,
                                "edit_reason": null,
                                "can_view_edit_history": true,
                                "wiki": false,
                                "reviewable_id": 0,
                                "reviewable_score_count": 0,
                                "reviewable_score_pending_count": 0
                            }
                        ]
                    },
                    "id": 81
                }
            }

    """

    serializer_class = DiscoursePostWriteSerializer

    def create(self, request):
        """Method to handle POST request and call discourse to create the post
        """
        logger.info('+ DiscoursePostView.post')
        data = request.data

        logger.info('+ DiscoursePostView.post'+json.dumps(data))
        if data['category_name'] == '':
            category_details = None
        else:
            category_details = {'category_name': data['category_name'],
                                'parent_name': data['parent_category_name'],
                                'category_colour': data['category_colour'],
                                'category_text_colour': data['category_text_colour']}

        if data['post_title'] == '':
            post_details = None
        else:
            post_details = {'title': data['post_title'],
                            'content': data['post_content'],
                            'tags': json.loads(data['post_tags'])}

        error, post_url, error_message = create_discourse_post(request.user, category_details, post_details)

        logger.info('- DiscoursePostView.post')
        if error:
            return Response({"message": error_message})
        else:
            return Response({"Post url": post_url})

    def list(self, request):
        """Method to handle GET request and call discourse to list posts for a topic
        """
        logger.info('+ DiscoursePostView.get')
        query_params = request.query_params
        logger.info('+ DiscoursePostView.get'+json.dumps(query_params))

        discourse_api_key = settings.DISCOURSE_API_KEY

        if discourse_api_key:
            post_title = request.query_params.get('post_title', None)
            error, posts = list_discourse_posts_for_topic(post_title)
        else:
            logger.info('- DiscoursePostView.no key')
            return Response({"message": "Discourse Not Available - No API key supplied"})

        logger.info('- DiscoursePostView.get')
        if error:
            return Response({"message": "No Posts Found"})
        else:
            return Response({"Posts": posts})


def create_csv_from_dict(input_dict, title=None, filename=None):
    """ Write a CSV file containing data from an input dictionary and return a URLto the file in the media
        directory.
    """

    if not filename:
        filename = 'download'

    media_root = settings.MEDIA_ROOT
    unique_dir = str(uuid.uuid4())
    # /code/media/downloads/unique_dir
    download_path = os.path.join(media_root, 'downloads', unique_dir)
    os.makedirs(download_path, exist_ok=True)

    download_file = os.path.join(download_path, filename)

    # Remove file if it already exists
    if os.path.isfile(download_file):
        os.remove(download_file)

    with open(download_file, "w", newline='') as csvfile:
        if title:
            csvfile.write(title)
            csvfile.write("\n")

    df = pd.DataFrame.from_dict(input_dict)
    df.to_csv(download_file, mode='a', header=True, index=False)

    return download_file


class DictToCsv(viewsets.ViewSet):
    """Django view that takes a dictionary and returns a download link to a CSV file with the data.

    Methods
    -------
    allowed requests:
        - GET: Return the CSV file given the link - note that this will remove the file on the media directory.
        - POST: Return a link to a CSV file containing the input dictionary
    url:
       api/dicttocsv
    get params:
       file_url: url returned in the post request

       Returns: CSV file when passed url.

    post params:
       title: string to place on the first line of the CSV file.
       input_dict: dictionary containing CSV data to place in the CSV file

       Returns: url to be passed to GET.

    Example Input for Get
       http://127.0.0.1:8080/api/dicttocsv/?file_url=/code/media/downloads/6bc70a04-9675-4079-924e-b0ab460cb206/download

    Example Input for Post
    ----------------------

    {
    "title": "https://fragalysis.xchem.diamond.ac.uk/viewer/react/landing",
    "dict": [{
                    " compound - id0 ": " CHEMSPACE - BB: CSC012451475 ",
                    " compound - id1 ": " ",
                    " smiles ": " Cc1ccncc1C(N)C(C)(C)C ",
                    " mol ": " CC( = O)Nc1cnccc1C ",
                    " vector ": " CC1CCCCC1[101Xe]",
                    " class ": " blue ",
                    " compoundClass ": " blue ",
                    " ChemPlp ": " ",
                    " MM - GBSA Nwat = 0 ": " ",
                            " STDEV0 ": " ",
                            " MM - GBSA Nwat = 30 ": " ",
                            " STDEV30 ": " ",
                            " MM - GBSA Nwat = 60 ": " "
                        },
                        {
                            " compound - id0 ": " ",
                            " compound - id1 ": " ",
                            " smiles ": " CC( = O)NCCc1c[nH]c2c(C(c3ccc(Br)s3)[NH + ]3CCN(C( = O)CCl)CC3)cccc12 ",
                            " mol ": " ",
                            " vector ": " ",
                            " class ": " ",
                            " compoundClass ": " ",
                            " ChemPlp ": -101.073,
                            " MM - GBSA Nwat = 0 ": -38.8862,
                            " STDEV0 ": 5.3589001,
                            " MM - GBSA Nwat = 30 ": -77.167603,
                            " STDEV30 ": 5.5984998,
                            " MM - GBSA Nwat = 60 ": -84.075401
        }]
    }

    """

    serializer_class = DictToCsvSerializer

    def list(self, request):
        """Method to handle GET request
        """
        file_url = request.GET.get('file_url')

        if file_url and os.path.isfile(file_url):
            with open(file_url) as csvfile:
                # return file and tidy up.
                response = HttpResponse(csvfile, content_type='text/csv')
                response['Content-Disposition'] = 'attachment; filename=download.csv'
                shutil.rmtree(os.path.dirname(file_url), ignore_errors=True)
                return response
        else:
            return Response("Please provide file_url parameter")

    def create(self, request):
        """Method to handle POST request
        """

        logger.info('+ DictToCsv.post')
        input_dict = request.data['dict']
        input_title = request.data['title']

        if not input_dict:
            return Response({"message": "Please enter Dictionary"})
        else:
            filename_url = create_csv_from_dict(input_dict, input_title)

        return Response({"file_url": filename_url})
